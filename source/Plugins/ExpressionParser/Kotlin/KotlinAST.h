//===-- KotlinAST.h ---------------------------------------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

// DO NOT EDIT.
// Generated by gen_Kotlin_ast.py

#ifndef liblldb_KotlinAST_h
#define liblldb_KotlinAST_h

#include "lldb/lldb-forward.h"
#include "lldb/lldb-private.h"
#include "llvm/Support/Casting.h"
#include "llvm/IR/Function.h"
#include "Plugins/ExpressionParser/Kotlin/KotlinLexer.h"

namespace lldb_private
{

class KotlinASTNode
{
  public:
    typedef KotlinLexer::TokenType TokenType;
    typedef KotlinLexer::Token Token;
    enum ChanDir
    {
        eChanBidir,
        eChanSend,
        eChanRecv,
    };
    enum NodeKind
    {
        eBadDecl,
        eFuncDecl,
        eGenDecl,
        eArrayType,
        eBadExpr,
        eBasicLit,
        eBinaryExpr,
        eIdent,
        eCallExpr,
        eChanType,
        eCompositeLit,
        eEllipsis,
        eFuncType,
        eFuncLit,
        eIndexExpr,
        eInterfaceType,
        eKeyValueExpr,
        eMapType,
        eParenExpr,
        eSelectorExpr,
        eSliceExpr,
        eStarExpr,
        eStructType,
        eTypeAssertExpr,
        eUnaryExpr,
        eImportSpec,
        eTypeSpec,
        eValueSpec,
        eAssignStmt,
        eBadStmt,
        eBlockStmt,
        eBranchStmt,
        eCaseClause,
        eCommClause,
        eDeclStmt,
        eDeferStmt,
        eEmptyStmt,
        eExprStmt,
        eForStmt,
        eIfStmt,
        eIncDecStmt,
        eLabeledStmt,
        eRangeStmt,
        eReturnStmt,
        eSelectStmt,
        eSendStmt,
        eSwitchStmt,
        eTypeSwitchStmt,
        eField,
        eFieldList,
    };

    virtual ~KotlinASTNode() = default;

    NodeKind
    GetKind() const
    {
        return m_kind;
    }

    virtual const char *GetKindName() const = 0;

    template <typename V> void WalkChildren(V &v);

  protected:
    explicit KotlinASTNode(NodeKind kind) : m_kind(kind) { }

  private:
    const NodeKind m_kind;

    KotlinASTNode(const KotlinASTNode &) = delete;
    const KotlinASTNode &operator=(const KotlinASTNode &) = delete;
};


class KotlinASTDecl : public KotlinASTNode
{
  public:
    template <typename R, typename V> R Visit(V *v) const;

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() >= eBadDecl && n->GetKind() <= eGenDecl;
    }

  protected:
    explicit KotlinASTDecl(NodeKind kind) : KotlinASTNode(kind) { }
  private:

    KotlinASTDecl(const KotlinASTDecl &) = delete;
    const KotlinASTDecl &operator=(const KotlinASTDecl &) = delete;
};

class KotlinASTExpr : public KotlinASTNode
{
  public:
    template <typename R, typename V> R Visit(V *v) const;

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() >= eArrayType && n->GetKind() <= eUnaryExpr;
    }

  protected:
    explicit KotlinASTExpr(NodeKind kind) : KotlinASTNode(kind) { }
  private:

    KotlinASTExpr(const KotlinASTExpr &) = delete;
    const KotlinASTExpr &operator=(const KotlinASTExpr &) = delete;
};

class KotlinASTSpec : public KotlinASTNode
{
  public:
    template <typename R, typename V> R Visit(V *v) const;

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() >= eImportSpec && n->GetKind() <= eValueSpec;
    }

  protected:
    explicit KotlinASTSpec(NodeKind kind) : KotlinASTNode(kind) { }
  private:

    KotlinASTSpec(const KotlinASTSpec &) = delete;
    const KotlinASTSpec &operator=(const KotlinASTSpec &) = delete;
};

class KotlinASTStmt : public KotlinASTNode
{
  public:
    template <typename R, typename V> R Visit(V *v) const;

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() >= eAssignStmt && n->GetKind() <= eTypeSwitchStmt;
    }

  protected:
    explicit KotlinASTStmt(NodeKind kind) : KotlinASTNode(kind) { }
  private:

    KotlinASTStmt(const KotlinASTStmt &) = delete;
    const KotlinASTStmt &operator=(const KotlinASTStmt &) = delete;
};


class KotlinASTArrayType : public KotlinASTExpr
{
  public:
    KotlinASTArrayType(KotlinASTExpr *len, KotlinASTExpr *elt) : KotlinASTExpr(eArrayType), m_len_up(len), m_elt_up(elt) {}
    ~KotlinASTArrayType() override = default;

    const char *
    GetKindName() const override
    {
        return "ArrayType";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eArrayType;
    }
    
    const KotlinASTExpr *
    GetLen() const
    {
        return m_len_up.get();
    }
    void
    SetLen(KotlinASTExpr *len)
    {
        m_len_up.reset(len);
    }

    const KotlinASTExpr *
    GetElt() const
    {
        return m_elt_up.get();
    }
    void
    SetElt(KotlinASTExpr *elt)
    {
        m_elt_up.reset(elt);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTExpr> m_len_up;
    std::unique_ptr<KotlinASTExpr> m_elt_up;

    KotlinASTArrayType(const KotlinASTArrayType &) = delete;
    const KotlinASTArrayType &operator=(const KotlinASTArrayType &) = delete;
};

class KotlinASTAssignStmt : public KotlinASTStmt
{
  public:
    explicit KotlinASTAssignStmt(bool define) : KotlinASTStmt(eAssignStmt), m_define(define) {}
    ~KotlinASTAssignStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "AssignStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eAssignStmt;
    }
    
    size_t
    NumLhs() const
    {
        return m_lhs.size();
    }
    const KotlinASTExpr *
    GetLhs(int i) const
    {
        return m_lhs[i].get();
    }
    void
    AddLhs(KotlinASTExpr *lhs)
    {
        m_lhs.push_back(std::unique_ptr<KotlinASTExpr>(lhs));
    }

    size_t
    NumRhs() const
    {
        return m_rhs.size();
    }
    const KotlinASTExpr *
    GetRhs(int i) const
    {
        return m_rhs[i].get();
    }
    void
    AddRhs(KotlinASTExpr *rhs)
    {
        m_rhs.push_back(std::unique_ptr<KotlinASTExpr>(rhs));
    }

    bool 
    GetDefine() const
    {
        return m_define;
    }
    void
    SetDefine(bool define)
    {
        m_define = define;
    }

  private:
    friend class KotlinASTNode;
    std::vector<std::unique_ptr<KotlinASTExpr> > m_lhs;
    std::vector<std::unique_ptr<KotlinASTExpr> > m_rhs;
    bool m_define;

    KotlinASTAssignStmt(const KotlinASTAssignStmt &) = delete;
    const KotlinASTAssignStmt &operator=(const KotlinASTAssignStmt &) = delete;
};

class KotlinASTBadDecl : public KotlinASTDecl
{
  public:
    KotlinASTBadDecl() : KotlinASTDecl(eBadDecl) {}
    ~KotlinASTBadDecl() override = default;

    const char *
    GetKindName() const override
    {
        return "BadDecl";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eBadDecl;
    }
    
    KotlinASTBadDecl(const KotlinASTBadDecl &) = delete;
    const KotlinASTBadDecl &operator=(const KotlinASTBadDecl &) = delete;
};

class KotlinASTBadExpr : public KotlinASTExpr
{
  public:
    KotlinASTBadExpr() : KotlinASTExpr(eBadExpr) {}
    ~KotlinASTBadExpr() override = default;

    const char *
    GetKindName() const override
    {
        return "BadExpr";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eBadExpr;
    }
    
    KotlinASTBadExpr(const KotlinASTBadExpr &) = delete;
    const KotlinASTBadExpr &operator=(const KotlinASTBadExpr &) = delete;
};

class KotlinASTBadStmt : public KotlinASTStmt
{
  public:
    KotlinASTBadStmt() : KotlinASTStmt(eBadStmt) {}
    ~KotlinASTBadStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "BadStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eBadStmt;
    }
    
    KotlinASTBadStmt(const KotlinASTBadStmt &) = delete;
    const KotlinASTBadStmt &operator=(const KotlinASTBadStmt &) = delete;
};

class KotlinASTBasicLit : public KotlinASTExpr
{
  public:
    explicit KotlinASTBasicLit(Token value) : KotlinASTExpr(eBasicLit), m_value(value) {}
    ~KotlinASTBasicLit() override = default;

    const char *
    GetKindName() const override
    {
        return "BasicLit";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eBasicLit;
    }
    
    Token 
    GetValue() const
    {
        return m_value;
    }
    void
    SetValue(Token value)
    {
        m_value = value;
    }

  private:
    friend class KotlinASTNode;
    Token m_value;

    KotlinASTBasicLit(const KotlinASTBasicLit &) = delete;
    const KotlinASTBasicLit &operator=(const KotlinASTBasicLit &) = delete;
};

class KotlinASTBinaryExpr : public KotlinASTExpr
{
  public:
    KotlinASTBinaryExpr(KotlinASTExpr *x, KotlinASTExpr *y, TokenType op) : KotlinASTExpr(eBinaryExpr), m_x_up(x), m_y_up(y), m_op(op) {}
    ~KotlinASTBinaryExpr() override = default;

    const char *
    GetKindName() const override
    {
        return "BinaryExpr";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eBinaryExpr;
    }
    
    const KotlinASTExpr *
    GetX() const
    {
        return m_x_up.get();
    }
    void
    SetX(KotlinASTExpr *x)
    {
        m_x_up.reset(x);
    }

    const KotlinASTExpr *
    GetY() const
    {
        return m_y_up.get();
    }
    void
    SetY(KotlinASTExpr *y)
    {
        m_y_up.reset(y);
    }

    TokenType 
    GetOp() const
    {
        return m_op;
    }
    void
    SetOp(TokenType op)
    {
        m_op = op;
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTExpr> m_x_up;
    std::unique_ptr<KotlinASTExpr> m_y_up;
    TokenType m_op;

    KotlinASTBinaryExpr(const KotlinASTBinaryExpr &) = delete;
    const KotlinASTBinaryExpr &operator=(const KotlinASTBinaryExpr &) = delete;
};

class KotlinASTBlockStmt : public KotlinASTStmt
{
  public:
    KotlinASTBlockStmt() : KotlinASTStmt(eBlockStmt) {}
    ~KotlinASTBlockStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "BlockStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eBlockStmt;
    }
    
    size_t
    NumList() const
    {
        return m_list.size();
    }
    const KotlinASTStmt *
    GetList(int i) const
    {
        return m_list[i].get();
    }
    void
    AddList(KotlinASTStmt *list)
    {
        m_list.push_back(std::unique_ptr<KotlinASTStmt>(list));
    }

  private:
    friend class KotlinASTNode;
    std::vector<std::unique_ptr<KotlinASTStmt> > m_list;

    KotlinASTBlockStmt(const KotlinASTBlockStmt &) = delete;
    const KotlinASTBlockStmt &operator=(const KotlinASTBlockStmt &) = delete;
};

class KotlinASTIdent : public KotlinASTExpr
{
  public:
    explicit KotlinASTIdent(Token name) : KotlinASTExpr(eIdent), m_name(name) {}
    ~KotlinASTIdent() override = default;

    const char *
    GetKindName() const override
    {
        return "Ident";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eIdent;
    }
    
    Token 
    GetName() const
    {
        return m_name;
    }
    void
    SetName(Token name)
    {
        m_name = name;
    }

  private:
    friend class KotlinASTNode;
    Token m_name;

    KotlinASTIdent(const KotlinASTIdent &) = delete;
    const KotlinASTIdent &operator=(const KotlinASTIdent &) = delete;
};

class KotlinASTBranchStmt : public KotlinASTStmt
{
  public:
    KotlinASTBranchStmt(KotlinASTIdent *label, TokenType tok) : KotlinASTStmt(eBranchStmt), m_label_up(label), m_tok(tok) {}
    ~KotlinASTBranchStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "BranchStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eBranchStmt;
    }
    
    const KotlinASTIdent *
    GetLabel() const
    {
        return m_label_up.get();
    }
    void
    SetLabel(KotlinASTIdent *label)
    {
        m_label_up.reset(label);
    }

    TokenType 
    GetTok() const
    {
        return m_tok;
    }
    void
    SetTok(TokenType tok)
    {
        m_tok = tok;
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTIdent> m_label_up;
    TokenType m_tok;

    KotlinASTBranchStmt(const KotlinASTBranchStmt &) = delete;
    const KotlinASTBranchStmt &operator=(const KotlinASTBranchStmt &) = delete;
};

class KotlinASTCallExpr : public KotlinASTExpr
{
  public:
    explicit KotlinASTCallExpr(bool ellipsis) : KotlinASTExpr(eCallExpr), m_ellipsis(ellipsis) {}
    ~KotlinASTCallExpr() override = default;

    const char *
    GetKindName() const override
    {
        return "CallExpr";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eCallExpr;
    }
    
    const KotlinASTExpr *
    GetFun() const
    {
        return m_fun_up.get();
    }
    void
    SetFun(KotlinASTExpr *fun)
    {
        m_fun_up.reset(fun);
    }

    size_t
    NumArgs() const
    {
        return m_args.size();
    }
    const KotlinASTExpr *
    GetArgs(int i) const
    {
        return m_args[i].get();
    }
    void
    AddArgs(KotlinASTExpr *args)
    {
        m_args.push_back(std::unique_ptr<KotlinASTExpr>(args));
    }

    bool 
    GetEllipsis() const
    {
        return m_ellipsis;
    }
    void
    SetEllipsis(bool ellipsis)
    {
        m_ellipsis = ellipsis;
    }

    void SetFunction(llvm::Function *function) {
        m_function = function;
    }

    llvm::Function *GetFunction() const {
        return m_function;
    }
  private:
    llvm::Function *m_function;
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTExpr> m_fun_up;
    std::vector<std::unique_ptr<KotlinASTExpr> > m_args;
    bool m_ellipsis;

    KotlinASTCallExpr(const KotlinASTCallExpr &) = delete;
    const KotlinASTCallExpr &operator=(const KotlinASTCallExpr &) = delete;
};

class KotlinASTCaseClause : public KotlinASTStmt
{
  public:
    KotlinASTCaseClause() : KotlinASTStmt(eCaseClause) {}
    ~KotlinASTCaseClause() override = default;

    const char *
    GetKindName() const override
    {
        return "CaseClause";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eCaseClause;
    }
    
    size_t
    NumList() const
    {
        return m_list.size();
    }
    const KotlinASTExpr *
    GetList(int i) const
    {
        return m_list[i].get();
    }
    void
    AddList(KotlinASTExpr *list)
    {
        m_list.push_back(std::unique_ptr<KotlinASTExpr>(list));
    }

    size_t
    NumBody() const
    {
        return m_body.size();
    }
    const KotlinASTStmt *
    GetBody(int i) const
    {
        return m_body[i].get();
    }
    void
    AddBody(KotlinASTStmt *body)
    {
        m_body.push_back(std::unique_ptr<KotlinASTStmt>(body));
    }

  private:
    friend class KotlinASTNode;
    std::vector<std::unique_ptr<KotlinASTExpr> > m_list;
    std::vector<std::unique_ptr<KotlinASTStmt> > m_body;

    KotlinASTCaseClause(const KotlinASTCaseClause &) = delete;
    const KotlinASTCaseClause &operator=(const KotlinASTCaseClause &) = delete;
};

class KotlinASTChanType : public KotlinASTExpr
{
  public:
    KotlinASTChanType(ChanDir dir, KotlinASTExpr *value) : KotlinASTExpr(eChanType), m_dir(dir), m_value_up(value) {}
    ~KotlinASTChanType() override = default;

    const char *
    GetKindName() const override
    {
        return "ChanType";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eChanType;
    }
    
    ChanDir 
    GetDir() const
    {
        return m_dir;
    }
    void
    SetDir(ChanDir dir)
    {
        m_dir = dir;
    }

    const KotlinASTExpr *
    GetValue() const
    {
        return m_value_up.get();
    }
    void
    SetValue(KotlinASTExpr *value)
    {
        m_value_up.reset(value);
    }

  private:
    friend class KotlinASTNode;
    ChanDir m_dir;
    std::unique_ptr<KotlinASTExpr> m_value_up;

    KotlinASTChanType(const KotlinASTChanType &) = delete;
    const KotlinASTChanType &operator=(const KotlinASTChanType &) = delete;
};

class KotlinASTCommClause : public KotlinASTStmt
{
  public:
    KotlinASTCommClause() : KotlinASTStmt(eCommClause) {}
    ~KotlinASTCommClause() override = default;

    const char *
    GetKindName() const override
    {
        return "CommClause";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eCommClause;
    }
    
    const KotlinASTStmt *
    GetComm() const
    {
        return m_comm_up.get();
    }
    void
    SetComm(KotlinASTStmt *comm)
    {
        m_comm_up.reset(comm);
    }

    size_t
    NumBody() const
    {
        return m_body.size();
    }
    const KotlinASTStmt *
    GetBody(int i) const
    {
        return m_body[i].get();
    }
    void
    AddBody(KotlinASTStmt *body)
    {
        m_body.push_back(std::unique_ptr<KotlinASTStmt>(body));
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTStmt> m_comm_up;
    std::vector<std::unique_ptr<KotlinASTStmt> > m_body;

    KotlinASTCommClause(const KotlinASTCommClause &) = delete;
    const KotlinASTCommClause &operator=(const KotlinASTCommClause &) = delete;
};

class KotlinASTCompositeLit : public KotlinASTExpr
{
  public:
    KotlinASTCompositeLit() : KotlinASTExpr(eCompositeLit) {}
    ~KotlinASTCompositeLit() override = default;

    const char *
    GetKindName() const override
    {
        return "CompositeLit";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eCompositeLit;
    }
    
    const KotlinASTExpr *
    GetType() const
    {
        return m_type_up.get();
    }
    void
    SetType(KotlinASTExpr *type)
    {
        m_type_up.reset(type);
    }

    size_t
    NumElts() const
    {
        return m_elts.size();
    }
    const KotlinASTExpr *
    GetElts(int i) const
    {
        return m_elts[i].get();
    }
    void
    AddElts(KotlinASTExpr *elts)
    {
        m_elts.push_back(std::unique_ptr<KotlinASTExpr>(elts));
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTExpr> m_type_up;
    std::vector<std::unique_ptr<KotlinASTExpr> > m_elts;

    KotlinASTCompositeLit(const KotlinASTCompositeLit &) = delete;
    const KotlinASTCompositeLit &operator=(const KotlinASTCompositeLit &) = delete;
};

class KotlinASTDeclStmt : public KotlinASTStmt
{
  public:
    explicit KotlinASTDeclStmt(KotlinASTDecl *decl) : KotlinASTStmt(eDeclStmt), m_decl_up(decl) {}
    ~KotlinASTDeclStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "DeclStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eDeclStmt;
    }
    
    const KotlinASTDecl *
    GetDecl() const
    {
        return m_decl_up.get();
    }
    void
    SetDecl(KotlinASTDecl *decl)
    {
        m_decl_up.reset(decl);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTDecl> m_decl_up;

    KotlinASTDeclStmt(const KotlinASTDeclStmt &) = delete;
    const KotlinASTDeclStmt &operator=(const KotlinASTDeclStmt &) = delete;
};

class KotlinASTDeferStmt : public KotlinASTStmt
{
  public:
    explicit KotlinASTDeferStmt(KotlinASTCallExpr *call) : KotlinASTStmt(eDeferStmt), m_call_up(call) {}
    ~KotlinASTDeferStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "DeferStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eDeferStmt;
    }
    
    const KotlinASTCallExpr *
    GetCall() const
    {
        return m_call_up.get();
    }
    void
    SetCall(KotlinASTCallExpr *call)
    {
        m_call_up.reset(call);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTCallExpr> m_call_up;

    KotlinASTDeferStmt(const KotlinASTDeferStmt &) = delete;
    const KotlinASTDeferStmt &operator=(const KotlinASTDeferStmt &) = delete;
};

class KotlinASTEllipsis : public KotlinASTExpr
{
  public:
    explicit KotlinASTEllipsis(KotlinASTExpr *elt) : KotlinASTExpr(eEllipsis), m_elt_up(elt) {}
    ~KotlinASTEllipsis() override = default;

    const char *
    GetKindName() const override
    {
        return "Ellipsis";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eEllipsis;
    }
    
    const KotlinASTExpr *
    GetElt() const
    {
        return m_elt_up.get();
    }
    void
    SetElt(KotlinASTExpr *elt)
    {
        m_elt_up.reset(elt);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTExpr> m_elt_up;

    KotlinASTEllipsis(const KotlinASTEllipsis &) = delete;
    const KotlinASTEllipsis &operator=(const KotlinASTEllipsis &) = delete;
};

class KotlinASTEmptyStmt : public KotlinASTStmt
{
  public:
    KotlinASTEmptyStmt() : KotlinASTStmt(eEmptyStmt) {}
    ~KotlinASTEmptyStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "EmptyStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eEmptyStmt;
    }
    
    KotlinASTEmptyStmt(const KotlinASTEmptyStmt &) = delete;
    const KotlinASTEmptyStmt &operator=(const KotlinASTEmptyStmt &) = delete;
};

class KotlinASTExprStmt : public KotlinASTStmt
{
  public:
    explicit KotlinASTExprStmt(KotlinASTExpr *x) : KotlinASTStmt(eExprStmt), m_x_up(x) {}
    ~KotlinASTExprStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "ExprStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eExprStmt;
    }
    
    const KotlinASTExpr *
    GetX() const
    {
        return m_x_up.get();
    }
    void
    SetX(KotlinASTExpr *x)
    {
        m_x_up.reset(x);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTExpr> m_x_up;

    KotlinASTExprStmt(const KotlinASTExprStmt &) = delete;
    const KotlinASTExprStmt &operator=(const KotlinASTExprStmt &) = delete;
};

class KotlinASTField : public KotlinASTNode
{
  public:
    KotlinASTField() : KotlinASTNode(eField) {}
    ~KotlinASTField() override = default;

    const char *
    GetKindName() const override
    {
        return "Field";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eField;
    }
    
    size_t
    NumNames() const
    {
        return m_names.size();
    }
    const KotlinASTIdent *
    GetNames(int i) const
    {
        return m_names[i].get();
    }
    void
    AddNames(KotlinASTIdent *names)
    {
        m_names.push_back(std::unique_ptr<KotlinASTIdent>(names));
    }

    const KotlinASTExpr *
    GetType() const
    {
        return m_type_up.get();
    }
    void
    SetType(KotlinASTExpr *type)
    {
        m_type_up.reset(type);
    }

    const KotlinASTBasicLit *
    GetTag() const
    {
        return m_tag_up.get();
    }
    void
    SetTag(KotlinASTBasicLit *tag)
    {
        m_tag_up.reset(tag);
    }

  private:
    friend class KotlinASTNode;
    std::vector<std::unique_ptr<KotlinASTIdent> > m_names;
    std::unique_ptr<KotlinASTExpr> m_type_up;
    std::unique_ptr<KotlinASTBasicLit> m_tag_up;

    KotlinASTField(const KotlinASTField &) = delete;
    const KotlinASTField &operator=(const KotlinASTField &) = delete;
};

class KotlinASTFieldList : public KotlinASTNode
{
  public:
    KotlinASTFieldList() : KotlinASTNode(eFieldList) {}
    ~KotlinASTFieldList() override = default;

    const char *
    GetKindName() const override
    {
        return "FieldList";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eFieldList;
    }
    
    size_t
    NumList() const
    {
        return m_list.size();
    }
    const KotlinASTField *
    GetList(int i) const
    {
        return m_list[i].get();
    }
    void
    AddList(KotlinASTField *list)
    {
        m_list.push_back(std::unique_ptr<KotlinASTField>(list));
    }

  private:
    friend class KotlinASTNode;
    std::vector<std::unique_ptr<KotlinASTField> > m_list;

    KotlinASTFieldList(const KotlinASTFieldList &) = delete;
    const KotlinASTFieldList &operator=(const KotlinASTFieldList &) = delete;
};

class KotlinASTForStmt : public KotlinASTStmt
{
  public:
    KotlinASTForStmt(KotlinASTStmt *init, KotlinASTExpr *cond, KotlinASTStmt *post, KotlinASTBlockStmt *body) : KotlinASTStmt(eForStmt), m_init_up(init), m_cond_up(cond), m_post_up(post), m_body_up(body) {}
    ~KotlinASTForStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "ForStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eForStmt;
    }
    
    const KotlinASTStmt *
    GetInit() const
    {
        return m_init_up.get();
    }
    void
    SetInit(KotlinASTStmt *init)
    {
        m_init_up.reset(init);
    }

    const KotlinASTExpr *
    GetCond() const
    {
        return m_cond_up.get();
    }
    void
    SetCond(KotlinASTExpr *cond)
    {
        m_cond_up.reset(cond);
    }

    const KotlinASTStmt *
    GetPost() const
    {
        return m_post_up.get();
    }
    void
    SetPost(KotlinASTStmt *post)
    {
        m_post_up.reset(post);
    }

    const KotlinASTBlockStmt *
    GetBody() const
    {
        return m_body_up.get();
    }
    void
    SetBody(KotlinASTBlockStmt *body)
    {
        m_body_up.reset(body);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTStmt> m_init_up;
    std::unique_ptr<KotlinASTExpr> m_cond_up;
    std::unique_ptr<KotlinASTStmt> m_post_up;
    std::unique_ptr<KotlinASTBlockStmt> m_body_up;

    KotlinASTForStmt(const KotlinASTForStmt &) = delete;
    const KotlinASTForStmt &operator=(const KotlinASTForStmt &) = delete;
};

class KotlinASTFuncType : public KotlinASTExpr
{
  public:
    KotlinASTFuncType(KotlinASTFieldList *params, KotlinASTFieldList *results) : KotlinASTExpr(eFuncType), m_params_up(params), m_results_up(results) {}
    ~KotlinASTFuncType() override = default;

    const char *
    GetKindName() const override
    {
        return "FuncType";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eFuncType;
    }
    
    const KotlinASTFieldList *
    GetParams() const
    {
        return m_params_up.get();
    }
    void
    SetParams(KotlinASTFieldList *params)
    {
        m_params_up.reset(params);
    }

    const KotlinASTFieldList *
    GetResults() const
    {
        return m_results_up.get();
    }
    void
    SetResults(KotlinASTFieldList *results)
    {
        m_results_up.reset(results);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTFieldList> m_params_up;
    std::unique_ptr<KotlinASTFieldList> m_results_up;

    KotlinASTFuncType(const KotlinASTFuncType &) = delete;
    const KotlinASTFuncType &operator=(const KotlinASTFuncType &) = delete;
};

class KotlinASTFuncDecl : public KotlinASTDecl
{
  public:
    KotlinASTFuncDecl(KotlinASTFieldList *recv, KotlinASTIdent *name, KotlinASTFuncType *type, KotlinASTBlockStmt *body) : KotlinASTDecl(eFuncDecl), m_recv_up(recv), m_name_up(name), m_type_up(type), m_body_up(body) {}
    ~KotlinASTFuncDecl() override = default;

    const char *
    GetKindName() const override
    {
        return "FuncDecl";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eFuncDecl;
    }
    
    const KotlinASTFieldList *
    GetRecv() const
    {
        return m_recv_up.get();
    }
    void
    SetRecv(KotlinASTFieldList *recv)
    {
        m_recv_up.reset(recv);
    }

    const KotlinASTIdent *
    GetName() const
    {
        return m_name_up.get();
    }
    void
    SetName(KotlinASTIdent *name)
    {
        m_name_up.reset(name);
    }

    const KotlinASTFuncType *
    GetType() const
    {
        return m_type_up.get();
    }
    void
    SetType(KotlinASTFuncType *type)
    {
        m_type_up.reset(type);
    }

    const KotlinASTBlockStmt *
    GetBody() const
    {
        return m_body_up.get();
    }
    void
    SetBody(KotlinASTBlockStmt *body)
    {
        m_body_up.reset(body);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTFieldList> m_recv_up;
    std::unique_ptr<KotlinASTIdent> m_name_up;
    std::unique_ptr<KotlinASTFuncType> m_type_up;
    std::unique_ptr<KotlinASTBlockStmt> m_body_up;

    KotlinASTFuncDecl(const KotlinASTFuncDecl &) = delete;
    const KotlinASTFuncDecl &operator=(const KotlinASTFuncDecl &) = delete;
};

class KotlinASTFuncLit : public KotlinASTExpr
{
  public:
    KotlinASTFuncLit(KotlinASTFuncType *type, KotlinASTBlockStmt *body) : KotlinASTExpr(eFuncLit), m_type_up(type), m_body_up(body) {}
    ~KotlinASTFuncLit() override = default;

    const char *
    GetKindName() const override
    {
        return "FuncLit";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eFuncLit;
    }
    
    const KotlinASTFuncType *
    GetType() const
    {
        return m_type_up.get();
    }
    void
    SetType(KotlinASTFuncType *type)
    {
        m_type_up.reset(type);
    }

    const KotlinASTBlockStmt *
    GetBody() const
    {
        return m_body_up.get();
    }
    void
    SetBody(KotlinASTBlockStmt *body)
    {
        m_body_up.reset(body);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTFuncType> m_type_up;
    std::unique_ptr<KotlinASTBlockStmt> m_body_up;

    KotlinASTFuncLit(const KotlinASTFuncLit &) = delete;
    const KotlinASTFuncLit &operator=(const KotlinASTFuncLit &) = delete;
};

class KotlinASTGenDecl : public KotlinASTDecl
{
  public:
    explicit KotlinASTGenDecl(TokenType tok) : KotlinASTDecl(eGenDecl), m_tok(tok) {}
    ~KotlinASTGenDecl() override = default;

    const char *
    GetKindName() const override
    {
        return "GenDecl";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eGenDecl;
    }
    
    TokenType 
    GetTok() const
    {
        return m_tok;
    }
    void
    SetTok(TokenType tok)
    {
        m_tok = tok;
    }

    size_t
    NumSpecs() const
    {
        return m_specs.size();
    }
    const KotlinASTSpec *
    GetSpecs(int i) const
    {
        return m_specs[i].get();
    }
    void
    AddSpecs(KotlinASTSpec *specs)
    {
        m_specs.push_back(std::unique_ptr<KotlinASTSpec>(specs));
    }

  private:
    friend class KotlinASTNode;
    TokenType m_tok;
    std::vector<std::unique_ptr<KotlinASTSpec> > m_specs;

    KotlinASTGenDecl(const KotlinASTGenDecl &) = delete;
    const KotlinASTGenDecl &operator=(const KotlinASTGenDecl &) = delete;
};

class KotlinASTIfStmt : public KotlinASTStmt
{
  public:
    KotlinASTIfStmt(KotlinASTStmt *init, KotlinASTExpr *cond, KotlinASTBlockStmt *body, KotlinASTStmt *els) : KotlinASTStmt(eIfStmt), m_init_up(init), m_cond_up(cond), m_body_up(body), m_els_up(els) {}
    ~KotlinASTIfStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "IfStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eIfStmt;
    }
    
    const KotlinASTStmt *
    GetInit() const
    {
        return m_init_up.get();
    }
    void
    SetInit(KotlinASTStmt *init)
    {
        m_init_up.reset(init);
    }

    const KotlinASTExpr *
    GetCond() const
    {
        return m_cond_up.get();
    }
    void
    SetCond(KotlinASTExpr *cond)
    {
        m_cond_up.reset(cond);
    }

    const KotlinASTBlockStmt *
    GetBody() const
    {
        return m_body_up.get();
    }
    void
    SetBody(KotlinASTBlockStmt *body)
    {
        m_body_up.reset(body);
    }

    const KotlinASTStmt *
    GetEls() const
    {
        return m_els_up.get();
    }
    void
    SetEls(KotlinASTStmt *els)
    {
        m_els_up.reset(els);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTStmt> m_init_up;
    std::unique_ptr<KotlinASTExpr> m_cond_up;
    std::unique_ptr<KotlinASTBlockStmt> m_body_up;
    std::unique_ptr<KotlinASTStmt> m_els_up;

    KotlinASTIfStmt(const KotlinASTIfStmt &) = delete;
    const KotlinASTIfStmt &operator=(const KotlinASTIfStmt &) = delete;
};

class KotlinASTImportSpec : public KotlinASTSpec
{
  public:
    KotlinASTImportSpec(KotlinASTIdent *name, KotlinASTBasicLit *path) : KotlinASTSpec(eImportSpec), m_name_up(name), m_path_up(path) {}
    ~KotlinASTImportSpec() override = default;

    const char *
    GetKindName() const override
    {
        return "ImportSpec";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eImportSpec;
    }
    
    const KotlinASTIdent *
    GetName() const
    {
        return m_name_up.get();
    }
    void
    SetName(KotlinASTIdent *name)
    {
        m_name_up.reset(name);
    }

    const KotlinASTBasicLit *
    GetPath() const
    {
        return m_path_up.get();
    }
    void
    SetPath(KotlinASTBasicLit *path)
    {
        m_path_up.reset(path);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTIdent> m_name_up;
    std::unique_ptr<KotlinASTBasicLit> m_path_up;

    KotlinASTImportSpec(const KotlinASTImportSpec &) = delete;
    const KotlinASTImportSpec &operator=(const KotlinASTImportSpec &) = delete;
};

class KotlinASTIncDecStmt : public KotlinASTStmt
{
  public:
    KotlinASTIncDecStmt(KotlinASTExpr *x, TokenType tok) : KotlinASTStmt(eIncDecStmt), m_x_up(x), m_tok(tok) {}
    ~KotlinASTIncDecStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "IncDecStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eIncDecStmt;
    }
    
    const KotlinASTExpr *
    GetX() const
    {
        return m_x_up.get();
    }
    void
    SetX(KotlinASTExpr *x)
    {
        m_x_up.reset(x);
    }

    TokenType 
    GetTok() const
    {
        return m_tok;
    }
    void
    SetTok(TokenType tok)
    {
        m_tok = tok;
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTExpr> m_x_up;
    TokenType m_tok;

    KotlinASTIncDecStmt(const KotlinASTIncDecStmt &) = delete;
    const KotlinASTIncDecStmt &operator=(const KotlinASTIncDecStmt &) = delete;
};

class KotlinASTIndexExpr : public KotlinASTExpr
{
  public:
    KotlinASTIndexExpr(KotlinASTExpr *x, KotlinASTExpr *index) : KotlinASTExpr(eIndexExpr), m_x_up(x), m_index_up(index) {}
    ~KotlinASTIndexExpr() override = default;

    const char *
    GetKindName() const override
    {
        return "IndexExpr";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eIndexExpr;
    }
    
    const KotlinASTExpr *
    GetX() const
    {
        return m_x_up.get();
    }
    void
    SetX(KotlinASTExpr *x)
    {
        m_x_up.reset(x);
    }

    const KotlinASTExpr *
    GetIndex() const
    {
        return m_index_up.get();
    }
    void
    SetIndex(KotlinASTExpr *index)
    {
        m_index_up.reset(index);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTExpr> m_x_up;
    std::unique_ptr<KotlinASTExpr> m_index_up;

    KotlinASTIndexExpr(const KotlinASTIndexExpr &) = delete;
    const KotlinASTIndexExpr &operator=(const KotlinASTIndexExpr &) = delete;
};

class KotlinASTInterfaceType : public KotlinASTExpr
{
  public:
    explicit KotlinASTInterfaceType(KotlinASTFieldList *methods) : KotlinASTExpr(eInterfaceType), m_methods_up(methods) {}
    ~KotlinASTInterfaceType() override = default;

    const char *
    GetKindName() const override
    {
        return "InterfaceType";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eInterfaceType;
    }
    
    const KotlinASTFieldList *
    GetMethods() const
    {
        return m_methods_up.get();
    }
    void
    SetMethods(KotlinASTFieldList *methods)
    {
        m_methods_up.reset(methods);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTFieldList> m_methods_up;

    KotlinASTInterfaceType(const KotlinASTInterfaceType &) = delete;
    const KotlinASTInterfaceType &operator=(const KotlinASTInterfaceType &) = delete;
};

class KotlinASTKeyValueExpr : public KotlinASTExpr
{
  public:
    KotlinASTKeyValueExpr(KotlinASTExpr *key, KotlinASTExpr *value) : KotlinASTExpr(eKeyValueExpr), m_key_up(key), m_value_up(value) {}
    ~KotlinASTKeyValueExpr() override = default;

    const char *
    GetKindName() const override
    {
        return "KeyValueExpr";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eKeyValueExpr;
    }
    
    const KotlinASTExpr *
    GetKey() const
    {
        return m_key_up.get();
    }
    void
    SetKey(KotlinASTExpr *key)
    {
        m_key_up.reset(key);
    }

    const KotlinASTExpr *
    GetValue() const
    {
        return m_value_up.get();
    }
    void
    SetValue(KotlinASTExpr *value)
    {
        m_value_up.reset(value);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTExpr> m_key_up;
    std::unique_ptr<KotlinASTExpr> m_value_up;

    KotlinASTKeyValueExpr(const KotlinASTKeyValueExpr &) = delete;
    const KotlinASTKeyValueExpr &operator=(const KotlinASTKeyValueExpr &) = delete;
};

class KotlinASTLabeledStmt : public KotlinASTStmt
{
  public:
    KotlinASTLabeledStmt(KotlinASTIdent *label, KotlinASTStmt *stmt) : KotlinASTStmt(eLabeledStmt), m_label_up(label), m_stmt_up(stmt) {}
    ~KotlinASTLabeledStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "LabeledStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eLabeledStmt;
    }
    
    const KotlinASTIdent *
    GetLabel() const
    {
        return m_label_up.get();
    }
    void
    SetLabel(KotlinASTIdent *label)
    {
        m_label_up.reset(label);
    }

    const KotlinASTStmt *
    GetStmt() const
    {
        return m_stmt_up.get();
    }
    void
    SetStmt(KotlinASTStmt *stmt)
    {
        m_stmt_up.reset(stmt);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTIdent> m_label_up;
    std::unique_ptr<KotlinASTStmt> m_stmt_up;

    KotlinASTLabeledStmt(const KotlinASTLabeledStmt &) = delete;
    const KotlinASTLabeledStmt &operator=(const KotlinASTLabeledStmt &) = delete;
};

class KotlinASTMapType : public KotlinASTExpr
{
  public:
    KotlinASTMapType(KotlinASTExpr *key, KotlinASTExpr *value) : KotlinASTExpr(eMapType), m_key_up(key), m_value_up(value) {}
    ~KotlinASTMapType() override = default;

    const char *
    GetKindName() const override
    {
        return "MapType";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eMapType;
    }
    
    const KotlinASTExpr *
    GetKey() const
    {
        return m_key_up.get();
    }
    void
    SetKey(KotlinASTExpr *key)
    {
        m_key_up.reset(key);
    }

    const KotlinASTExpr *
    GetValue() const
    {
        return m_value_up.get();
    }
    void
    SetValue(KotlinASTExpr *value)
    {
        m_value_up.reset(value);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTExpr> m_key_up;
    std::unique_ptr<KotlinASTExpr> m_value_up;

    KotlinASTMapType(const KotlinASTMapType &) = delete;
    const KotlinASTMapType &operator=(const KotlinASTMapType &) = delete;
};

class KotlinASTParenExpr : public KotlinASTExpr
{
  public:
    explicit KotlinASTParenExpr(KotlinASTExpr *x) : KotlinASTExpr(eParenExpr), m_x_up(x) {}
    ~KotlinASTParenExpr() override = default;

    const char *
    GetKindName() const override
    {
        return "ParenExpr";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eParenExpr;
    }
    
    const KotlinASTExpr *
    GetX() const
    {
        return m_x_up.get();
    }
    void
    SetX(KotlinASTExpr *x)
    {
        m_x_up.reset(x);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTExpr> m_x_up;

    KotlinASTParenExpr(const KotlinASTParenExpr &) = delete;
    const KotlinASTParenExpr &operator=(const KotlinASTParenExpr &) = delete;
};

class KotlinASTRangeStmt : public KotlinASTStmt
{
  public:
    KotlinASTRangeStmt(KotlinASTExpr *key, KotlinASTExpr *value, bool define, KotlinASTExpr *x, KotlinASTBlockStmt *body) : KotlinASTStmt(eRangeStmt), m_key_up(key), m_value_up(value), m_define(define), m_x_up(x), m_body_up(body) {}
    ~KotlinASTRangeStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "RangeStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eRangeStmt;
    }
    
    const KotlinASTExpr *
    GetKey() const
    {
        return m_key_up.get();
    }
    void
    SetKey(KotlinASTExpr *key)
    {
        m_key_up.reset(key);
    }

    const KotlinASTExpr *
    GetValue() const
    {
        return m_value_up.get();
    }
    void
    SetValue(KotlinASTExpr *value)
    {
        m_value_up.reset(value);
    }

    bool 
    GetDefine() const
    {
        return m_define;
    }
    void
    SetDefine(bool define)
    {
        m_define = define;
    }

    const KotlinASTExpr *
    GetX() const
    {
        return m_x_up.get();
    }
    void
    SetX(KotlinASTExpr *x)
    {
        m_x_up.reset(x);
    }

    const KotlinASTBlockStmt *
    GetBody() const
    {
        return m_body_up.get();
    }
    void
    SetBody(KotlinASTBlockStmt *body)
    {
        m_body_up.reset(body);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTExpr> m_key_up;
    std::unique_ptr<KotlinASTExpr> m_value_up;
    bool m_define;
    std::unique_ptr<KotlinASTExpr> m_x_up;
    std::unique_ptr<KotlinASTBlockStmt> m_body_up;

    KotlinASTRangeStmt(const KotlinASTRangeStmt &) = delete;
    const KotlinASTRangeStmt &operator=(const KotlinASTRangeStmt &) = delete;
};

class KotlinASTReturnStmt : public KotlinASTStmt
{
  public:
    KotlinASTReturnStmt() : KotlinASTStmt(eReturnStmt) {}
    ~KotlinASTReturnStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "ReturnStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eReturnStmt;
    }
    
    size_t
    NumResults() const
    {
        return m_results.size();
    }
    const KotlinASTExpr *
    GetResults(int i) const
    {
        return m_results[i].get();
    }
    void
    AddResults(KotlinASTExpr *results)
    {
        m_results.push_back(std::unique_ptr<KotlinASTExpr>(results));
    }

  private:
    friend class KotlinASTNode;
    std::vector<std::unique_ptr<KotlinASTExpr> > m_results;

    KotlinASTReturnStmt(const KotlinASTReturnStmt &) = delete;
    const KotlinASTReturnStmt &operator=(const KotlinASTReturnStmt &) = delete;
};

class KotlinASTSelectStmt : public KotlinASTStmt
{
  public:
    explicit KotlinASTSelectStmt(KotlinASTBlockStmt *body) : KotlinASTStmt(eSelectStmt), m_body_up(body) {}
    ~KotlinASTSelectStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "SelectStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eSelectStmt;
    }
    
    const KotlinASTBlockStmt *
    GetBody() const
    {
        return m_body_up.get();
    }
    void
    SetBody(KotlinASTBlockStmt *body)
    {
        m_body_up.reset(body);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTBlockStmt> m_body_up;

    KotlinASTSelectStmt(const KotlinASTSelectStmt &) = delete;
    const KotlinASTSelectStmt &operator=(const KotlinASTSelectStmt &) = delete;
};

class KotlinASTSelectorExpr : public KotlinASTExpr
{
  public:
    KotlinASTSelectorExpr(KotlinASTExpr *x, KotlinASTIdent *sel) : KotlinASTExpr(eSelectorExpr), m_x_up(x), m_sel_up(sel) {}
    ~KotlinASTSelectorExpr() override = default;

    const char *
    GetKindName() const override
    {
        return "SelectorExpr";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eSelectorExpr;
    }
    
    const KotlinASTExpr *
    GetX() const
    {
        return m_x_up.get();
    }
    void
    SetX(KotlinASTExpr *x)
    {
        m_x_up.reset(x);
    }

    const KotlinASTIdent *
    GetSel() const
    {
        return m_sel_up.get();
    }
    void
    SetSel(KotlinASTIdent *sel)
    {
        m_sel_up.reset(sel);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTExpr> m_x_up;
    std::unique_ptr<KotlinASTIdent> m_sel_up;

    KotlinASTSelectorExpr(const KotlinASTSelectorExpr &) = delete;
    const KotlinASTSelectorExpr &operator=(const KotlinASTSelectorExpr &) = delete;
};

class KotlinASTSendStmt : public KotlinASTStmt
{
  public:
    KotlinASTSendStmt(KotlinASTExpr *chan, KotlinASTExpr *value) : KotlinASTStmt(eSendStmt), m_chan_up(chan), m_value_up(value) {}
    ~KotlinASTSendStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "SendStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eSendStmt;
    }
    
    const KotlinASTExpr *
    GetChan() const
    {
        return m_chan_up.get();
    }
    void
    SetChan(KotlinASTExpr *chan)
    {
        m_chan_up.reset(chan);
    }

    const KotlinASTExpr *
    GetValue() const
    {
        return m_value_up.get();
    }
    void
    SetValue(KotlinASTExpr *value)
    {
        m_value_up.reset(value);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTExpr> m_chan_up;
    std::unique_ptr<KotlinASTExpr> m_value_up;

    KotlinASTSendStmt(const KotlinASTSendStmt &) = delete;
    const KotlinASTSendStmt &operator=(const KotlinASTSendStmt &) = delete;
};

class KotlinASTSliceExpr : public KotlinASTExpr
{
  public:
    KotlinASTSliceExpr(KotlinASTExpr *x, KotlinASTExpr *low, KotlinASTExpr *high, KotlinASTExpr *max, bool slice3) : KotlinASTExpr(eSliceExpr), m_x_up(x), m_low_up(low), m_high_up(high), m_max_up(max), m_slice3(slice3) {}
    ~KotlinASTSliceExpr() override = default;

    const char *
    GetKindName() const override
    {
        return "SliceExpr";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eSliceExpr;
    }
    
    const KotlinASTExpr *
    GetX() const
    {
        return m_x_up.get();
    }
    void
    SetX(KotlinASTExpr *x)
    {
        m_x_up.reset(x);
    }

    const KotlinASTExpr *
    GetLow() const
    {
        return m_low_up.get();
    }
    void
    SetLow(KotlinASTExpr *low)
    {
        m_low_up.reset(low);
    }

    const KotlinASTExpr *
    GetHigh() const
    {
        return m_high_up.get();
    }
    void
    SetHigh(KotlinASTExpr *high)
    {
        m_high_up.reset(high);
    }

    const KotlinASTExpr *
    GetMax() const
    {
        return m_max_up.get();
    }
    void
    SetMax(KotlinASTExpr *max)
    {
        m_max_up.reset(max);
    }

    bool 
    GetSlice3() const
    {
        return m_slice3;
    }
    void
    SetSlice3(bool slice3)
    {
        m_slice3 = slice3;
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTExpr> m_x_up;
    std::unique_ptr<KotlinASTExpr> m_low_up;
    std::unique_ptr<KotlinASTExpr> m_high_up;
    std::unique_ptr<KotlinASTExpr> m_max_up;
    bool m_slice3;

    KotlinASTSliceExpr(const KotlinASTSliceExpr &) = delete;
    const KotlinASTSliceExpr &operator=(const KotlinASTSliceExpr &) = delete;
};

class KotlinASTStarExpr : public KotlinASTExpr
{
  public:
    explicit KotlinASTStarExpr(KotlinASTExpr *x) : KotlinASTExpr(eStarExpr), m_x_up(x) {}
    ~KotlinASTStarExpr() override = default;

    const char *
    GetKindName() const override
    {
        return "StarExpr";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eStarExpr;
    }
    
    const KotlinASTExpr *
    GetX() const
    {
        return m_x_up.get();
    }
    void
    SetX(KotlinASTExpr *x)
    {
        m_x_up.reset(x);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTExpr> m_x_up;

    KotlinASTStarExpr(const KotlinASTStarExpr &) = delete;
    const KotlinASTStarExpr &operator=(const KotlinASTStarExpr &) = delete;
};

class KotlinASTStructType : public KotlinASTExpr
{
  public:
    explicit KotlinASTStructType(KotlinASTFieldList *fields) : KotlinASTExpr(eStructType), m_fields_up(fields) {}
    ~KotlinASTStructType() override = default;

    const char *
    GetKindName() const override
    {
        return "StructType";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eStructType;
    }
    
    const KotlinASTFieldList *
    GetFields() const
    {
        return m_fields_up.get();
    }
    void
    SetFields(KotlinASTFieldList *fields)
    {
        m_fields_up.reset(fields);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTFieldList> m_fields_up;

    KotlinASTStructType(const KotlinASTStructType &) = delete;
    const KotlinASTStructType &operator=(const KotlinASTStructType &) = delete;
};

class KotlinASTSwitchStmt : public KotlinASTStmt
{
  public:
    KotlinASTSwitchStmt(KotlinASTStmt *init, KotlinASTExpr *tag, KotlinASTBlockStmt *body) : KotlinASTStmt(eSwitchStmt), m_init_up(init), m_tag_up(tag), m_body_up(body) {}
    ~KotlinASTSwitchStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "SwitchStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eSwitchStmt;
    }
    
    const KotlinASTStmt *
    GetInit() const
    {
        return m_init_up.get();
    }
    void
    SetInit(KotlinASTStmt *init)
    {
        m_init_up.reset(init);
    }

    const KotlinASTExpr *
    GetTag() const
    {
        return m_tag_up.get();
    }
    void
    SetTag(KotlinASTExpr *tag)
    {
        m_tag_up.reset(tag);
    }

    const KotlinASTBlockStmt *
    GetBody() const
    {
        return m_body_up.get();
    }
    void
    SetBody(KotlinASTBlockStmt *body)
    {
        m_body_up.reset(body);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTStmt> m_init_up;
    std::unique_ptr<KotlinASTExpr> m_tag_up;
    std::unique_ptr<KotlinASTBlockStmt> m_body_up;

    KotlinASTSwitchStmt(const KotlinASTSwitchStmt &) = delete;
    const KotlinASTSwitchStmt &operator=(const KotlinASTSwitchStmt &) = delete;
};

class KotlinASTTypeAssertExpr : public KotlinASTExpr
{
  public:
    KotlinASTTypeAssertExpr(KotlinASTExpr *x, KotlinASTExpr *type) : KotlinASTExpr(eTypeAssertExpr), m_x_up(x), m_type_up(type) {}
    ~KotlinASTTypeAssertExpr() override = default;

    const char *
    GetKindName() const override
    {
        return "TypeAssertExpr";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eTypeAssertExpr;
    }
    
    const KotlinASTExpr *
    GetX() const
    {
        return m_x_up.get();
    }
    void
    SetX(KotlinASTExpr *x)
    {
        m_x_up.reset(x);
    }

    const KotlinASTExpr *
    GetType() const
    {
        return m_type_up.get();
    }
    void
    SetType(KotlinASTExpr *type)
    {
        m_type_up.reset(type);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTExpr> m_x_up;
    std::unique_ptr<KotlinASTExpr> m_type_up;

    KotlinASTTypeAssertExpr(const KotlinASTTypeAssertExpr &) = delete;
    const KotlinASTTypeAssertExpr &operator=(const KotlinASTTypeAssertExpr &) = delete;
};

class KotlinASTTypeSpec : public KotlinASTSpec
{
  public:
    KotlinASTTypeSpec(KotlinASTIdent *name, KotlinASTExpr *type) : KotlinASTSpec(eTypeSpec), m_name_up(name), m_type_up(type) {}
    ~KotlinASTTypeSpec() override = default;

    const char *
    GetKindName() const override
    {
        return "TypeSpec";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eTypeSpec;
    }
    
    const KotlinASTIdent *
    GetName() const
    {
        return m_name_up.get();
    }
    void
    SetName(KotlinASTIdent *name)
    {
        m_name_up.reset(name);
    }

    const KotlinASTExpr *
    GetType() const
    {
        return m_type_up.get();
    }
    void
    SetType(KotlinASTExpr *type)
    {
        m_type_up.reset(type);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTIdent> m_name_up;
    std::unique_ptr<KotlinASTExpr> m_type_up;

    KotlinASTTypeSpec(const KotlinASTTypeSpec &) = delete;
    const KotlinASTTypeSpec &operator=(const KotlinASTTypeSpec &) = delete;
};

class KotlinASTTypeSwitchStmt : public KotlinASTStmt
{
  public:
    KotlinASTTypeSwitchStmt(KotlinASTStmt *init, KotlinASTStmt *assign, KotlinASTBlockStmt *body) : KotlinASTStmt(eTypeSwitchStmt), m_init_up(init), m_assign_up(assign), m_body_up(body) {}
    ~KotlinASTTypeSwitchStmt() override = default;

    const char *
    GetKindName() const override
    {
        return "TypeSwitchStmt";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eTypeSwitchStmt;
    }
    
    const KotlinASTStmt *
    GetInit() const
    {
        return m_init_up.get();
    }
    void
    SetInit(KotlinASTStmt *init)
    {
        m_init_up.reset(init);
    }

    const KotlinASTStmt *
    GetAssign() const
    {
        return m_assign_up.get();
    }
    void
    SetAssign(KotlinASTStmt *assign)
    {
        m_assign_up.reset(assign);
    }

    const KotlinASTBlockStmt *
    GetBody() const
    {
        return m_body_up.get();
    }
    void
    SetBody(KotlinASTBlockStmt *body)
    {
        m_body_up.reset(body);
    }

  private:
    friend class KotlinASTNode;
    std::unique_ptr<KotlinASTStmt> m_init_up;
    std::unique_ptr<KotlinASTStmt> m_assign_up;
    std::unique_ptr<KotlinASTBlockStmt> m_body_up;

    KotlinASTTypeSwitchStmt(const KotlinASTTypeSwitchStmt &) = delete;
    const KotlinASTTypeSwitchStmt &operator=(const KotlinASTTypeSwitchStmt &) = delete;
};

class KotlinASTUnaryExpr : public KotlinASTExpr
{
  public:
    KotlinASTUnaryExpr(TokenType op, KotlinASTExpr *x) : KotlinASTExpr(eUnaryExpr), m_op(op), m_x_up(x) {}
    ~KotlinASTUnaryExpr() override = default;

    const char *
    GetKindName() const override
    {
        return "UnaryExpr";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eUnaryExpr;
    }
    
    TokenType 
    GetOp() const
    {
        return m_op;
    }
    void
    SetOp(TokenType op)
    {
        m_op = op;
    }

    const KotlinASTExpr *
    GetX() const
    {
        return m_x_up.get();
    }
    void
    SetX(KotlinASTExpr *x)
    {
        m_x_up.reset(x);
    }

  private:
    friend class KotlinASTNode;
    TokenType m_op;
    std::unique_ptr<KotlinASTExpr> m_x_up;

    KotlinASTUnaryExpr(const KotlinASTUnaryExpr &) = delete;
    const KotlinASTUnaryExpr &operator=(const KotlinASTUnaryExpr &) = delete;
};

class KotlinASTValueSpec : public KotlinASTSpec
{
  public:
    KotlinASTValueSpec() : KotlinASTSpec(eValueSpec) {}
    ~KotlinASTValueSpec() override = default;

    const char *
    GetKindName() const override
    {
        return "ValueSpec";
    }

    static bool
    classof(const KotlinASTNode *n)
    {
        return n->GetKind() == eValueSpec;
    }
    
    size_t
    NumNames() const
    {
        return m_names.size();
    }
    const KotlinASTIdent *
    GetNames(int i) const
    {
        return m_names[i].get();
    }
    void
    AddNames(KotlinASTIdent *names)
    {
        m_names.push_back(std::unique_ptr<KotlinASTIdent>(names));
    }

    const KotlinASTExpr *
    GetType() const
    {
        return m_type_up.get();
    }
    void
    SetType(KotlinASTExpr *type)
    {
        m_type_up.reset(type);
    }

    size_t
    NumValues() const
    {
        return m_values.size();
    }
    const KotlinASTExpr *
    GetValues(int i) const
    {
        return m_values[i].get();
    }
    void
    AddValues(KotlinASTExpr *values)
    {
        m_values.push_back(std::unique_ptr<KotlinASTExpr>(values));
    }

  private:
    friend class KotlinASTNode;
    std::vector<std::unique_ptr<KotlinASTIdent> > m_names;
    std::unique_ptr<KotlinASTExpr> m_type_up;
    std::vector<std::unique_ptr<KotlinASTExpr> > m_values;

    KotlinASTValueSpec(const KotlinASTValueSpec &) = delete;
    const KotlinASTValueSpec &operator=(const KotlinASTValueSpec &) = delete;
};


template <typename R, typename V>
R KotlinASTDecl::Visit(V* v) const
{
    switch(GetKind())
    {
    case eBadDecl:
        return v->VisitBadDecl(llvm::cast<const KotlinASTBadDecl>(this));
    case eFuncDecl:
        return v->VisitFuncDecl(llvm::cast<const KotlinASTFuncDecl>(this));
    case eGenDecl:
        return v->VisitGenDecl(llvm::cast<const KotlinASTGenDecl>(this));
    default:
        assert(false && "Invalid kind");
    }
}

template <typename R, typename V>
R KotlinASTExpr::Visit(V* v) const
{
    switch(GetKind())
    {
    case eArrayType:
        return v->VisitArrayType(llvm::cast<const KotlinASTArrayType>(this));
    case eBadExpr:
        return v->VisitBadExpr(llvm::cast<const KotlinASTBadExpr>(this));
    case eBasicLit:
        return v->VisitBasicLit(llvm::cast<const KotlinASTBasicLit>(this));
    case eBinaryExpr:
        return v->VisitBinaryExpr(llvm::cast<const KotlinASTBinaryExpr>(this));
    case eIdent:
        return v->VisitIdent(llvm::cast<const KotlinASTIdent>(this));
    case eCallExpr:
        return v->VisitCallExpr(llvm::cast<const KotlinASTCallExpr>(this));
    case eChanType:
        return v->VisitChanType(llvm::cast<const KotlinASTChanType>(this));
    case eCompositeLit:
        return v->VisitCompositeLit(llvm::cast<const KotlinASTCompositeLit>(this));
    case eEllipsis:
        return v->VisitEllipsis(llvm::cast<const KotlinASTEllipsis>(this));
    case eFuncType:
        return v->VisitFuncType(llvm::cast<const KotlinASTFuncType>(this));
    case eFuncLit:
        return v->VisitFuncLit(llvm::cast<const KotlinASTFuncLit>(this));
    case eIndexExpr:
        return v->VisitIndexExpr(llvm::cast<const KotlinASTIndexExpr>(this));
    case eInterfaceType:
        return v->VisitInterfaceType(llvm::cast<const KotlinASTInterfaceType>(this));
    case eKeyValueExpr:
        return v->VisitKeyValueExpr(llvm::cast<const KotlinASTKeyValueExpr>(this));
    case eMapType:
        return v->VisitMapType(llvm::cast<const KotlinASTMapType>(this));
    case eParenExpr:
        return v->VisitParenExpr(llvm::cast<const KotlinASTParenExpr>(this));
    case eSelectorExpr:
        return v->VisitSelectorExpr(llvm::cast<const KotlinASTSelectorExpr>(this));
    case eSliceExpr:
        return v->VisitSliceExpr(llvm::cast<const KotlinASTSliceExpr>(this));
    case eStarExpr:
        return v->VisitStarExpr(llvm::cast<const KotlinASTStarExpr>(this));
    case eStructType:
        return v->VisitStructType(llvm::cast<const KotlinASTStructType>(this));
    case eTypeAssertExpr:
        return v->VisitTypeAssertExpr(llvm::cast<const KotlinASTTypeAssertExpr>(this));
    case eUnaryExpr:
        return v->VisitUnaryExpr(llvm::cast<const KotlinASTUnaryExpr>(this));
    default:
        assert(false && "Invalid kind");
    }
}

template <typename R, typename V>
R KotlinASTSpec::Visit(V* v) const
{
    switch(GetKind())
    {
    case eImportSpec:
        return v->VisitImportSpec(llvm::cast<const KotlinASTImportSpec>(this));
    case eTypeSpec:
        return v->VisitTypeSpec(llvm::cast<const KotlinASTTypeSpec>(this));
    case eValueSpec:
        return v->VisitValueSpec(llvm::cast<const KotlinASTValueSpec>(this));
    default:
        assert(false && "Invalid kind");
    }
}

template <typename R, typename V>
R KotlinASTStmt::Visit(V* v) const
{
    switch(GetKind())
    {
    case eAssignStmt:
        return v->VisitAssignStmt(llvm::cast<const KotlinASTAssignStmt>(this));
    case eBadStmt:
        return v->VisitBadStmt(llvm::cast<const KotlinASTBadStmt>(this));
    case eBlockStmt:
        return v->VisitBlockStmt(llvm::cast<const KotlinASTBlockStmt>(this));
    case eBranchStmt:
        return v->VisitBranchStmt(llvm::cast<const KotlinASTBranchStmt>(this));
    case eCaseClause:
        return v->VisitCaseClause(llvm::cast<const KotlinASTCaseClause>(this));
    case eCommClause:
        return v->VisitCommClause(llvm::cast<const KotlinASTCommClause>(this));
    case eDeclStmt:
        return v->VisitDeclStmt(llvm::cast<const KotlinASTDeclStmt>(this));
    case eDeferStmt:
        return v->VisitDeferStmt(llvm::cast<const KotlinASTDeferStmt>(this));
    case eEmptyStmt:
        return v->VisitEmptyStmt(llvm::cast<const KotlinASTEmptyStmt>(this));
    case eExprStmt:
        return v->VisitExprStmt(llvm::cast<const KotlinASTExprStmt>(this));
    case eForStmt:
        return v->VisitForStmt(llvm::cast<const KotlinASTForStmt>(this));
    case eIfStmt:
        return v->VisitIfStmt(llvm::cast<const KotlinASTIfStmt>(this));
    case eIncDecStmt:
        return v->VisitIncDecStmt(llvm::cast<const KotlinASTIncDecStmt>(this));
    case eLabeledStmt:
        return v->VisitLabeledStmt(llvm::cast<const KotlinASTLabeledStmt>(this));
    case eRangeStmt:
        return v->VisitRangeStmt(llvm::cast<const KotlinASTRangeStmt>(this));
    case eReturnStmt:
        return v->VisitReturnStmt(llvm::cast<const KotlinASTReturnStmt>(this));
    case eSelectStmt:
        return v->VisitSelectStmt(llvm::cast<const KotlinASTSelectStmt>(this));
    case eSendStmt:
        return v->VisitSendStmt(llvm::cast<const KotlinASTSendStmt>(this));
    case eSwitchStmt:
        return v->VisitSwitchStmt(llvm::cast<const KotlinASTSwitchStmt>(this));
    case eTypeSwitchStmt:
        return v->VisitTypeSwitchStmt(llvm::cast<const KotlinASTTypeSwitchStmt>(this));
    default:
        assert(false && "Invalid kind");
    }
}

template <typename V>
void KotlinASTNode::WalkChildren(V &v)
{
    switch (m_kind)
    {


    case eArrayType:
        {
            KotlinASTArrayType *n = llvm::cast<KotlinASTArrayType>(this);
            (void)n;
            v(n->m_len_up.get());
            v(n->m_elt_up.get());
            return;
        }
    case eAssignStmt:
        {
            KotlinASTAssignStmt *n = llvm::cast<KotlinASTAssignStmt>(this);
            (void)n;
            for (auto& e : n->m_lhs) { v(e.get()); }
            for (auto& e : n->m_rhs) { v(e.get()); }
            return;
        }
    case eBasicLit:
        {
            KotlinASTBasicLit *n = llvm::cast<KotlinASTBasicLit>(this);
            (void)n;
            return;
        }
    case eBinaryExpr:
        {
            KotlinASTBinaryExpr *n = llvm::cast<KotlinASTBinaryExpr>(this);
            (void)n;
            v(n->m_x_up.get());
            v(n->m_y_up.get());
            return;
        }
    case eBlockStmt:
        {
            KotlinASTBlockStmt *n = llvm::cast<KotlinASTBlockStmt>(this);
            (void)n;
            for (auto& e : n->m_list) { v(e.get()); }
            return;
        }
    case eIdent:
        {
            KotlinASTIdent *n = llvm::cast<KotlinASTIdent>(this);
            (void)n;
            return;
        }
    case eBranchStmt:
        {
            KotlinASTBranchStmt *n = llvm::cast<KotlinASTBranchStmt>(this);
            (void)n;
            v(n->m_label_up.get());
            return;
        }
    case eCallExpr:
        {
            KotlinASTCallExpr *n = llvm::cast<KotlinASTCallExpr>(this);
            (void)n;
            v(n->m_fun_up.get());
            for (auto& e : n->m_args) { v(e.get()); }
            return;
        }
    case eCaseClause:
        {
            KotlinASTCaseClause *n = llvm::cast<KotlinASTCaseClause>(this);
            (void)n;
            for (auto& e : n->m_list) { v(e.get()); }
            for (auto& e : n->m_body) { v(e.get()); }
            return;
        }
    case eChanType:
        {
            KotlinASTChanType *n = llvm::cast<KotlinASTChanType>(this);
            (void)n;
            v(n->m_value_up.get());
            return;
        }
    case eCommClause:
        {
            KotlinASTCommClause *n = llvm::cast<KotlinASTCommClause>(this);
            (void)n;
            v(n->m_comm_up.get());
            for (auto& e : n->m_body) { v(e.get()); }
            return;
        }
    case eCompositeLit:
        {
            KotlinASTCompositeLit *n = llvm::cast<KotlinASTCompositeLit>(this);
            (void)n;
            v(n->m_type_up.get());
            for (auto& e : n->m_elts) { v(e.get()); }
            return;
        }
    case eDeclStmt:
        {
            KotlinASTDeclStmt *n = llvm::cast<KotlinASTDeclStmt>(this);
            (void)n;
            v(n->m_decl_up.get());
            return;
        }
    case eDeferStmt:
        {
            KotlinASTDeferStmt *n = llvm::cast<KotlinASTDeferStmt>(this);
            (void)n;
            v(n->m_call_up.get());
            return;
        }
    case eEllipsis:
        {
            KotlinASTEllipsis *n = llvm::cast<KotlinASTEllipsis>(this);
            (void)n;
            v(n->m_elt_up.get());
            return;
        }
    case eExprStmt:
        {
            KotlinASTExprStmt *n = llvm::cast<KotlinASTExprStmt>(this);
            (void)n;
            v(n->m_x_up.get());
            return;
        }
    case eField:
        {
            KotlinASTField *n = llvm::cast<KotlinASTField>(this);
            (void)n;
            for (auto& e : n->m_names) { v(e.get()); }
            v(n->m_type_up.get());
            v(n->m_tag_up.get());
            return;
        }
    case eFieldList:
        {
            KotlinASTFieldList *n = llvm::cast<KotlinASTFieldList>(this);
            (void)n;
            for (auto& e : n->m_list) { v(e.get()); }
            return;
        }
    case eForStmt:
        {
            KotlinASTForStmt *n = llvm::cast<KotlinASTForStmt>(this);
            (void)n;
            v(n->m_init_up.get());
            v(n->m_cond_up.get());
            v(n->m_post_up.get());
            v(n->m_body_up.get());
            return;
        }
    case eFuncType:
        {
            KotlinASTFuncType *n = llvm::cast<KotlinASTFuncType>(this);
            (void)n;
            v(n->m_params_up.get());
            v(n->m_results_up.get());
            return;
        }
    case eFuncDecl:
        {
            KotlinASTFuncDecl *n = llvm::cast<KotlinASTFuncDecl>(this);
            (void)n;
            v(n->m_recv_up.get());
            v(n->m_name_up.get());
            v(n->m_type_up.get());
            v(n->m_body_up.get());
            return;
        }
    case eFuncLit:
        {
            KotlinASTFuncLit *n = llvm::cast<KotlinASTFuncLit>(this);
            (void)n;
            v(n->m_type_up.get());
            v(n->m_body_up.get());
            return;
        }
    case eGenDecl:
        {
            KotlinASTGenDecl *n = llvm::cast<KotlinASTGenDecl>(this);
            (void)n;
            for (auto& e : n->m_specs) { v(e.get()); }
            return;
        }
    case eIfStmt:
        {
            KotlinASTIfStmt *n = llvm::cast<KotlinASTIfStmt>(this);
            (void)n;
            v(n->m_init_up.get());
            v(n->m_cond_up.get());
            v(n->m_body_up.get());
            v(n->m_els_up.get());
            return;
        }
    case eImportSpec:
        {
            KotlinASTImportSpec *n = llvm::cast<KotlinASTImportSpec>(this);
            (void)n;
            v(n->m_name_up.get());
            v(n->m_path_up.get());
            return;
        }
    case eIncDecStmt:
        {
            KotlinASTIncDecStmt *n = llvm::cast<KotlinASTIncDecStmt>(this);
            (void)n;
            v(n->m_x_up.get());
            return;
        }
    case eIndexExpr:
        {
            KotlinASTIndexExpr *n = llvm::cast<KotlinASTIndexExpr>(this);
            (void)n;
            v(n->m_x_up.get());
            v(n->m_index_up.get());
            return;
        }
    case eInterfaceType:
        {
            KotlinASTInterfaceType *n = llvm::cast<KotlinASTInterfaceType>(this);
            (void)n;
            v(n->m_methods_up.get());
            return;
        }
    case eKeyValueExpr:
        {
            KotlinASTKeyValueExpr *n = llvm::cast<KotlinASTKeyValueExpr>(this);
            (void)n;
            v(n->m_key_up.get());
            v(n->m_value_up.get());
            return;
        }
    case eLabeledStmt:
        {
            KotlinASTLabeledStmt *n = llvm::cast<KotlinASTLabeledStmt>(this);
            (void)n;
            v(n->m_label_up.get());
            v(n->m_stmt_up.get());
            return;
        }
    case eMapType:
        {
            KotlinASTMapType *n = llvm::cast<KotlinASTMapType>(this);
            (void)n;
            v(n->m_key_up.get());
            v(n->m_value_up.get());
            return;
        }
    case eParenExpr:
        {
            KotlinASTParenExpr *n = llvm::cast<KotlinASTParenExpr>(this);
            (void)n;
            v(n->m_x_up.get());
            return;
        }
    case eRangeStmt:
        {
            KotlinASTRangeStmt *n = llvm::cast<KotlinASTRangeStmt>(this);
            (void)n;
            v(n->m_key_up.get());
            v(n->m_value_up.get());
            v(n->m_x_up.get());
            v(n->m_body_up.get());
            return;
        }
    case eReturnStmt:
        {
            KotlinASTReturnStmt *n = llvm::cast<KotlinASTReturnStmt>(this);
            (void)n;
            for (auto& e : n->m_results) { v(e.get()); }
            return;
        }
    case eSelectStmt:
        {
            KotlinASTSelectStmt *n = llvm::cast<KotlinASTSelectStmt>(this);
            (void)n;
            v(n->m_body_up.get());
            return;
        }
    case eSelectorExpr:
        {
            KotlinASTSelectorExpr *n = llvm::cast<KotlinASTSelectorExpr>(this);
            (void)n;
            v(n->m_x_up.get());
            v(n->m_sel_up.get());
            return;
        }
    case eSendStmt:
        {
            KotlinASTSendStmt *n = llvm::cast<KotlinASTSendStmt>(this);
            (void)n;
            v(n->m_chan_up.get());
            v(n->m_value_up.get());
            return;
        }
    case eSliceExpr:
        {
            KotlinASTSliceExpr *n = llvm::cast<KotlinASTSliceExpr>(this);
            (void)n;
            v(n->m_x_up.get());
            v(n->m_low_up.get());
            v(n->m_high_up.get());
            v(n->m_max_up.get());
            return;
        }
    case eStarExpr:
        {
            KotlinASTStarExpr *n = llvm::cast<KotlinASTStarExpr>(this);
            (void)n;
            v(n->m_x_up.get());
            return;
        }
    case eStructType:
        {
            KotlinASTStructType *n = llvm::cast<KotlinASTStructType>(this);
            (void)n;
            v(n->m_fields_up.get());
            return;
        }
    case eSwitchStmt:
        {
            KotlinASTSwitchStmt *n = llvm::cast<KotlinASTSwitchStmt>(this);
            (void)n;
            v(n->m_init_up.get());
            v(n->m_tag_up.get());
            v(n->m_body_up.get());
            return;
        }
    case eTypeAssertExpr:
        {
            KotlinASTTypeAssertExpr *n = llvm::cast<KotlinASTTypeAssertExpr>(this);
            (void)n;
            v(n->m_x_up.get());
            v(n->m_type_up.get());
            return;
        }
    case eTypeSpec:
        {
            KotlinASTTypeSpec *n = llvm::cast<KotlinASTTypeSpec>(this);
            (void)n;
            v(n->m_name_up.get());
            v(n->m_type_up.get());
            return;
        }
    case eTypeSwitchStmt:
        {
            KotlinASTTypeSwitchStmt *n = llvm::cast<KotlinASTTypeSwitchStmt>(this);
            (void)n;
            v(n->m_init_up.get());
            v(n->m_assign_up.get());
            v(n->m_body_up.get());
            return;
        }
    case eUnaryExpr:
        {
            KotlinASTUnaryExpr *n = llvm::cast<KotlinASTUnaryExpr>(this);
            (void)n;
            v(n->m_x_up.get());
            return;
        }
    case eValueSpec:
        {
            KotlinASTValueSpec *n = llvm::cast<KotlinASTValueSpec>(this);
            (void)n;
            for (auto& e : n->m_names) { v(e.get()); }
            v(n->m_type_up.get());
            for (auto& e : n->m_values) { v(e.get()); }
            return;
        }

        case eEmptyStmt:
        case eBadDecl:
        case eBadExpr:
        case eBadStmt:
          break;
    }
}

}  // namespace lldb_private

#endif

